{"ast":null,"code":"/**\n * sechash\n *\n * Secure password hashing using salt and keystretching\n *\n * @author     James Brumond\n * @version    0.2.0\n * @copyright  Copyright 2012 James Brumond\n * @license    Dual licensed under MIT and GPL\n */\nvar oath = require('oath');\n\nvar crypto = require('crypto');\n\nvar defaultOptions = {\n  algorithm: 'sha1',\n  iterations: 2000,\n  includeMeta: true,\n  intervalLength: 500,\n  salt: function () {\n    return hash(this.algorithm, String(Math.random())).substring(0, 6);\n  }\n}; // ----------------------------------------------------------------------------\n//  Public functions\n\nexports.basicHash = function (alg, str) {\n  return hash(alg, str);\n};\n\nexports.testBasicHash = function (alg, str, testHash) {\n  return hash(alg, str) === testHash;\n};\n\nexports.strongHashSync = function (str, opts) {\n  opts = getOptions(opts);\n\n  for (var i = 0; i < opts.iterations; i++) {\n    str = hash(opts.algorithm, str + opts.salt);\n  }\n\n  return opts.meta + str;\n};\n\nexports.strongHash = function (str, opts, callback) {\n  var promise = new oath();\n\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = null;\n  }\n\n  opts = getOptions(opts);\n  asyncFor(opts.iterations, opts.intervalLength, function () {\n    str = hash(opts.algorithm, str + opts.salt);\n  }, function () {\n    done(promise, callback, opts.meta + str);\n  });\n  return promise.promise;\n};\n\nexports.testHashSync = function (str, hash, opts) {\n  opts = getOptions(opts, hash);\n  return exports.strongHashSync(str, opts) === hash;\n};\n\nexports.testHash = function (str, hash, opts, callback) {\n  var promise = new oath();\n\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = null;\n  }\n\n  opts = getOptions(opts, hash);\n  exports.strongHash(str, opts, function (err, result) {\n    done(promise, callback, hash === result);\n  });\n  return promise.promise;\n}; // ------------------------------------------------------------------\n//  Helpers\n\n\nfunction hash(alg, str) {\n  var hashsum = crypto.createHash(alg);\n  hashsum.update(str);\n  return hashsum.digest('hex');\n}\n\nfunction done(promise, callback, result) {\n  if (typeof callback === 'function') {\n    callback(null, result);\n  }\n\n  promise.resolve(result);\n}\n\nfunction getOptions(opts, hash) {\n  var result = {};\n  Object.keys(defaultOptions).forEach(function (key) {\n    result[key] = defaultOptions[key];\n  });\n  Object.keys(opts || {}).forEach(function (key) {\n    result[key] = opts[key];\n  });\n\n  if (typeof result.salt === 'function') {\n    result.salt = result.salt();\n  }\n\n  if (result.includeMeta) {\n    result.meta = result.salt + ':' + result.algorithm + ':' + result.iterations + ':';\n  } else {\n    result.meta = '';\n  }\n\n  if (hash && hash.indexOf(':') >= 0) {\n    hash = hash.split(':');\n    result.salt = hash[0];\n    result.algorithm = hash[1];\n    result.iterations = Number(hash[2]);\n  }\n\n  return result;\n}\n\nfunction asyncFor(count, intervalLength, func, callback) {\n  function runLoop() {\n    for (var i = 0; i < intervalLength && count; i++, count--) {\n      func(count, i);\n    }\n\n    if (count) {\n      process.nextTick(runLoop);\n    } else {\n      callback();\n    }\n  }\n\n  runLoop();\n}\n/* End of file sechash.js */","map":{"version":3,"sources":["C:/Users/Sameer/Desktop/KeepClone/keep/node_modules/sechash/lib/sechash.js"],"names":["oath","require","crypto","defaultOptions","algorithm","iterations","includeMeta","intervalLength","salt","hash","String","Math","random","substring","exports","basicHash","alg","str","testBasicHash","testHash","strongHashSync","opts","getOptions","i","meta","strongHash","callback","promise","asyncFor","done","testHashSync","err","result","hashsum","createHash","update","digest","resolve","Object","keys","forEach","key","indexOf","split","Number","count","func","runLoop","process","nextTick"],"mappings":"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","sourcesContent":["/**\n * sechash\n *\n * Secure password hashing using salt and keystretching\n *\n * @author     James Brumond\n * @version    0.2.0\n * @copyright  Copyright 2012 James Brumond\n * @license    Dual licensed under MIT and GPL\n */\n\t\nvar oath    = require('oath');\nvar crypto  = require('crypto');\n\nvar defaultOptions = {\n\talgorithm: 'sha1',\n\titerations: 2000,\n\tincludeMeta: true,\n\tintervalLength: 500,\n\tsalt: function() {\n\t\treturn hash(this.algorithm, String(Math.random())).substring(0, 6);\n\t}\n};\n\n// ----------------------------------------------------------------------------\n//  Public functions\n\nexports.basicHash = function(alg, str) {\n\treturn hash(alg, str);\n};\n\nexports.testBasicHash = function(alg, str, testHash) {\n\treturn (hash(alg, str) === testHash);\n};\n\nexports.strongHashSync = function(str, opts) {\n\topts = getOptions(opts);\n\tfor (var i = 0; i < opts.iterations; i++) {\n\t\tstr = hash(opts.algorithm, str + opts.salt);\n\t}\n\treturn opts.meta + str;\n};\n\nexports.strongHash = function(str, opts, callback) {\n\tvar promise = new oath();\n\tif (typeof opts === 'function') {\n\t\tcallback = opts;\n\t\topts = null;\n\t}\n\topts = getOptions(opts);\n\tasyncFor(opts.iterations, opts.intervalLength,\n\t\tfunction() {\n\t\t\tstr = hash(opts.algorithm, str + opts.salt);\n\t\t},\n\t\tfunction() {\n\t\t\tdone(promise, callback, opts.meta + str);\n\t\t}\n\t);\n\treturn promise.promise;\n};\n\nexports.testHashSync = function(str, hash, opts) {\n\topts = getOptions(opts, hash);\n\treturn (exports.strongHashSync(str, opts) === hash);\n};\n\nexports.testHash = function(str, hash, opts, callback) {\n\tvar promise = new oath();\n\tif (typeof opts === 'function') {\n\t\tcallback = opts;\n\t\topts = null;\n\t}\n\topts = getOptions(opts, hash);\n\texports.strongHash(str, opts, function(err, result) {\n\t\tdone(promise, callback, hash === result);\n\t});\n\treturn promise.promise;\n};\n\n\n\n// ------------------------------------------------------------------\n//  Helpers\n\nfunction hash(alg, str) {\n\tvar hashsum = crypto.createHash(alg);\n\thashsum.update(str);\n\treturn hashsum.digest('hex');\n}\n\nfunction done(promise, callback, result) {\n\tif (typeof callback === 'function') {\n\t\tcallback(null, result);\n\t}\n\tpromise.resolve(result);\n}\n\nfunction getOptions(opts, hash) {\n\tvar result = { };\n\tObject.keys(defaultOptions).forEach(function(key) {\n\t\tresult[key] = defaultOptions[key];\n\t});\n\tObject.keys(opts || { }).forEach(function(key) {\n\t\tresult[key] = opts[key];\n\t});\n\tif (typeof result.salt === 'function') {\n\t\tresult.salt = result.salt();\n\t}\n\tif (result.includeMeta) {\n\t\tresult.meta = result.salt + ':' + result.algorithm + ':' + result.iterations + ':'\n\t} else {\n\t\tresult.meta = '';\n\t}\n\tif (hash && hash.indexOf(':') >= 0) {\n\t\thash = hash.split(':');\n\t\tresult.salt = hash[0];\n\t\tresult.algorithm = hash[1];\n\t\tresult.iterations = Number(hash[2]);\n\t}\n\treturn result;\n}\n\nfunction asyncFor(count, intervalLength, func, callback) {\n\tfunction runLoop() {\n\t\tfor (var i = 0; (i < intervalLength && count); i++, count--) {\n\t\t\tfunc(count, i);\n\t\t}\n\t\tif (count) {\n\t\t\tprocess.nextTick(runLoop);\n\t\t} else {\n\t\t\tcallback();\n\t\t}\n\t}\n\trunLoop();\n}\n\n/* End of file sechash.js */\n"]},"metadata":{},"sourceType":"script"}